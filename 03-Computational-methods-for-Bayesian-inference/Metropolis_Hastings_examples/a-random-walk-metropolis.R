library(mvtnorm) # need to sample from multivariate normal and evaluate
                 # density of multivariate normal

# Data distribution: p(y | theta) = bivariate N(y | theta, I),
# where I is the 2x2 identity matrix and y = c(0, 0) is a 2-dimensional
# vector of 0s.
# Prior distribution: the improper prior p(theta) = 1
#
# We want to sample from the joint posterior for theta.
#
# Proposal distribution:
# The proposal distribution will also be bivariate normal,
# centered at the current iteration value of theta with a
# scaled version of I for the covariance.
# i.e., theta_star | theta^(t-1) ~ N(theta^(t-1) , const * I).
#
# Since the proposal distribution is not only symmetric,
# but depends only on the distance |theta_star - theta_current|,
# we can implement the  random walk metropolis algorithm
# because the ratio r simplifies to the ratio of posterior
# densities.

# Define function to perform metropolis algorithm
# B = number of cycles to run
# start = d-dimensional vector of starting values
# const = scaling constant c related to size of jump for
#         proposal distribution
mh = function(B, start, const) {
  # identity matrix for proposal distribution
  Imat = diag(length(start))
  # store iterations
  theta = matrix(0, nrow = B + 1, ncol = length(start))
  theta[1, ] = start # first row of matrix is starting values
	for (i in 2:(B + 1)) {
	  # use c to convert from matrix to vector
		theta_star = c(rmvnorm(1, theta[i - 1, ], const * Imat))
		# Because we're using a random walk M-H, the acceptance ratio
		# simplifies to the ratio of the likelihood functions evaluated at
    # observed values of c(0, 0)
		r = dmvnorm(c(0, 0), mean = theta_star, sigma = Imat) /
         dmvnorm(c(0, 0), mean = theta[i - 1,], sigma = Imat)
		if (runif(1) <= min(r, 1)) {
			theta[i,] = theta_star
		} else {
			theta[i,] = theta[i - 1,]
		}
	}
	return(theta)
}

B = 1000
mh1 = mh(B, c(0, 0), const = .2^2)
mh2 = mh(B, c(-3, 3), const = .2^2)
mh3 = mh(B, c(-3, -3), const = .2^2)
mh4 = mh(B, c(3, -3), const = .2^2)
mh5 = mh(B, c(3, 3), const = .2^2)

# Plot first 50 steps of M-H chain.  Note starting point.
plot(c(-4, 4), c(-4, 4), type = "n", xlab = "theta1", ylab = "theta2")
lines(mh1[1:51,])
lines(mh2[1:51,])
lines(mh3[1:51,])
lines(mh4[1:51,])
lines(mh5[1:51,])
points(c(-3, -3, 0, 3, 3), c(-3, 3, 0, -3, 3), pch = 20)
title("First 50 iterations of M-H chain")

# Plot all steps of M-H chain.  Note starting point.  Converges
# eventually
plot(c(-4, 4), c(-4, 4), type = "n", xlab = "theta1", ylab = "theta2")
lines(mh1)
lines(mh2)
lines(mh3)
lines(mh4)
lines(mh5)
points(c(-3, -3, 0, 3, 3), c(-3, 3, 0, -3, 3), pch = 20)
title("First 1000 iterations of M-H chain")

#plot second half of posterior sample
plot(mh1[(B/2 + 1):(B + 1), ], pch = ".", xlim = c(-4, 4), ylim = c(-4, 4),
     xlab = expression(theta[1]), ylab = expression(theta[2]))
points(mh2[(B/2 + 1):(B + 1), ], pch = ".")
points(mh3[(B/2 + 1):(B + 1), ], pch = ".")
points(mh4[(B/2 + 1):(B + 1), ], pch = ".")
points(mh5[(B/2 + 1):(B + 1), ], pch = ".")

# Try same things with a different proposal that allows for larger jumps
mh1 = mh(B, c(0, 0), const = 1)
mh2 = mh(B, c(-3, 3), const = 1)
mh3 = mh(B, c(-3, -3), const = 1)
mh4 = mh(B, c(3, -3), const = 1)
mh5 = mh(B, c(3, 3), const = 1)

# Plot first 50 steps of M-H chain.  Note starting point.
plot(c(-4, 4), c(-4, 4), type = "n",
     xlab = expression(theta[1]), ylab = expression(theta[2]))
lines(mh1[1:51,])
lines(mh2[1:51,])
lines(mh3[1:51,])
lines(mh4[1:51,])
lines(mh5[1:51,])
points(c(-3, -3, 0, 3, 3), c(-3, 3, 0, -3, 3), pch = 20)
title("First 50 iterations of M-H chain")

# Plot all steps of M-H chain.  Note starting point.  Converges
# eventually
plot(c(-4, 4), c(-4, 4), type = "n",
     xlab = expression(theta[1]), ylab = expression(theta[2]))
lines(mh1)
lines(mh2)
lines(mh3)
lines(mh4)
lines(mh5)
points(c(-3, -3, 0, 3, 3), c(-3, 3, 0, -3, 3), pch = 20)
title("Iterations of M-H chain")

#plot second half of posterior sample
plot(mh1[(B/2 + 1):(B + 1), ], pch = ".", xlim = c(-4, 4), ylim = c(-4, 4),
     xlab = expression(theta[1]), ylab = expression(theta[2]))
points(mh2[(B/2 + 1):(B + 1), ], pch = ".")
points(mh3[(B/2 + 1):(B + 1), ], pch = ".")
points(mh4[(B/2 + 1):(B + 1), ], pch = ".")
points(mh5[(B/2 + 1):(B + 1), ], pch = ".")